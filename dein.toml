#vim:set nobomb:set encoding=utf-8
########################################
#	Brief	dein Plugins
#	Author	KORYUOH
#	Create	
#	Update	2017/10/16
#	Version	1.10
#	Lazy : Not Lazy
########################################

[[plugins]]
repo = 'Shougo/dein.vim'

[[plugins]]
repo = 'Shougo/vimproc.vim'
if = '!has("kaoriya")'
hook_post_update = '''
	if dein#util#_is_window()
		let cmd = 'tools\\update-dll-mingw'
	elif dein#util#_is_cygwin()
		let cmd = 'make -f make_cygwin.mak'
	elif executable('gmake')
		let cmd = 'gmake'
	else
		cmd = 'make'
	endif
	let g:dein#plugin.build = cmd
'''


[[plugins]]
repo = 'osyo-manga/vim-precious'
depends = [ 'context_filetype.vim' ]

[[plugins]]
repo = 'Shougo/context_filetype.vim'

[[plugins]]
repo = 'cespare/vim-toml'
on_ft = 'toml'

[[plugins]]
repo = 'tomasr/molokai'
hook_add = '''
augroup SetColorScheme 
	au!
	au VimEnter * nested colorscheme molokai
augroup END
	'''

[[plugins]]
repo = 'kmszk/skyhawk'

[[plugins]]
repo = 'kmszk/skyknight'

[[plugins]]
repo = 'Shougo/unite.vim'
hook_add = '''
	nmap <leader>f :Unite file -buffer-name=UniteFiler<CR>
	nmap <leader>F :Unite file:**/*.{cpp,h} -buffer-name=UniteFiler<CR>
	nmap <leader>vg :Unite vimgrep -buffer-name=UniteQuickFix<CR>
	nmap <leader>cw :UniteResume UniteQuickFix<CR>
	nmap <leader>co :UniteResume UniteOutLiner<CR>
	nmap <leader>ul :Unite line -buffer-name=UniteOutLiner<CR>
	nmap <leader>ut :Unite tab -buffer-name=UniteOutLiner<CR>
	nmap <leader>ug :Unite grep::-S -buffer-name=UniteQuickFix<CR>
	nmap <leader>cg :Unite grep:.:-G\ \\.(h\\\|cpp) -buffer-name=UniteQuickFix<CR>
	if executable('pt')
		let g:unite_source_grep_command = 'pt'
		let g:unite_source_grep_default_opts = '--nogroup --nocolor'
		let g:unite_source_grep_recursive_opt = ''
		let g:unite_source_grep_encoding = 'utf-8'
	endif
'''


[[plugins]]
repo = 'Shougo/unite-outline'
hook_add = '''
nmap <C-W>u :Unite outline:! -buffer-name=UniteOutLiner<CR>
'''

[[plugins]]
repo = 'sgur/unite-qf'
hook_add='''
	nmap <leader>ucw :Unite qf -buffer-name=UniteQuickFix<CR>
'''



[[plugins]]
repo = 'ujihisa/neco-look'

[[plugins]]
repo = 'koron/codic-vim'

[[plugins]]
repo = 'rhysd/unite-codic.vim'
hook_add = '''
	nmap <leader>uc :Unite codic<CR>
'''

[[plugins]]
repo = 'terryma/vim-multiple-cursors'

[[plugins]]
repo = 'AndrewRadev/switch.vim'
hook_add = '''
let g:switch_mapping = "-"
'''

[[plugins]]
repo = 'itchyny/lightline.vim'
hook_add = '''
if !has("kaoriya")
	set laststatus=2
endif
'''

[[plugins]]
repo = 'ujihisa/unite-colorscheme'

[[plugins]]
repo = 'mattn/flappyvird-vim'

[[plugins]]
repo = 'glidenote/memolist.vim'
hook_add = '''
	if isdirectory(expand("~/.memolist"))
		let g:memolist_path = expand("~/.memolist")
	endif
	
	let g:memolist_unite        = 1
	let g:memolist_unite_source = "file"
	let g:memolist_unite_option = "-auto-preview -start-insert"
	function! s:UniteMemoList()
		let l:memolist_path = unite#util#path2directory(g:memolist_path)
		call unite#start([['file_rec',l:memolist_path ]])
	endfunction

	command! UniteMemoList call s:UniteMemoList()
	nmap <leader>mn :MemoNew<CR>
	nmap <leader>ml :MemoList<CR>
	nmap <leader>mg :MemoGrep<CR>
'''

[[plugins]]
repo = 'Shougo/neomru.vim'
on_source = ['unite.vim']
hook_add = '''
	nmap <leader>mf :Unite file_mru -buffer-name=UniteFiler<CR>
'''

[[plugins]]
repo = 'scrooloose/nerdtree'
hook_add = '''
" let g:NERDTreeDirArrows=1
let g:NERDTreeWinPos="right"
nmap <leader>nt :NERDTreeToggle<CR>
function! NERDTreeHighlightFile(extention, fg, bg, guifg, guibg )
	exec 'autocmd filetype nerdtree highlight '.a:extention.' ctermbg='.a:bg.' ctermfg='.a:fg.' guibg='.a:guibg.' guifg='.a:guifg
	exec 'autocmd filetype nerdtree syn match '. a:extention . ' #^\s\+./*'.a:extention.'$#'
endfunction

" call NERDTreeHighlightFile( 'cpp' , 'blue' , 'none' , '#4040ff' , '#151515' )

'''

[[plugins]]
repo = 'tomtom/tcomment_vim'

[[plugins]]
repo = 'mattn/invader-vim'   

[[plugins]]
repo = 'nathanaelkane/vim-indent-guides'
hook_add='''
let g:indent_guides_enable_on_vim_startup = 1
'''
[[plugins]]
repo = 'idbrii/vim-unreal'

[[plugins]]
repo = 'vim-jp/vimdoc-ja'
if = '!has("kaoriya")'
hook_add = '''
set helplang=ja,en
'''

[[plugins]]
repo = 'nfvs/vim-perforce'
if = 'executable("p4")'

[[plugins]]
repo = 'h1mesuke/vim-alignta'
hook_add = '''
vnoremap <leader>= :'<,'>Alignta =<CR>
'''

[[plugins]]
repo = 'Shougo/neocomplete.vim'
if = 'has("lua")'
on_i = 1
hook_add='''
let g:neocomplete#enable_at_startup = 1
let g:neocomplete#enable_smart_case = 1
let g:neocomplete#enable_underbar_completion = 1
let g:neocomplete#enable_camel_case_completion = 1
let g:neocomplete#max_list = 20
let g:neocomplete#auto_complete_start_length = 2
let g:neocomplete#enable_auto_close_preview = 0
autocmd! InsertLeave * silent! pclose!

let g:neocomplete#max_keyword_width = 10000

if !exists('g:neocomplete#force_ommni_input_patterns')
	let g:neocomplete#force_ommni_input_patterns = {}
endif
let g:neocomplete#force_ommni_input_patterns.cpp = '[^.[:digit:] *\t\%(/.\|->\)\w*\|\h\w+::\w*'

if isdirectory(expand('~/.vim/cache/neocomplete'))
	let g:neocomplete#data_directory = $HOME.'/.vim/cache/neocomplete'
endif

'''

[[plugins]]
repo = 'Shougo/neosnippet-snippets'
on_source = ['neosnippet.vim']
# depends = ['neosnippet.vim' ]

[[plugins]]
repo = 'Shougo/neosnippet.vim'
depends = ['neosnippet-snippets' ]
on_i = 1
hook_add='''

let s:snippet_folder = '~/snippet'

if exists(s:snippet_folder)
	let g:neosnippet#snippets_directory = s:snippet_folder
endif


""" TAB Completion
inoremap <expr><TAB>  pumvisible() ? "\<C-p>" : "<S-TAB>"
" Plugin key-mappings.
" Note: It must be "imap" and "smap".  It uses <Plug> mappings.
imap <C-k>     <Plug>(neosnippet_expand_or_jump)
smap <C-k>     <Plug>(neosnippet_expand_or_jump)
xmap <C-k>     <Plug>(neosnippet_expand_target)

" SuperTab like snippets behavior.
" Note: It must be "imap" and "smap".  It uses <Plug> mappings.
imap <C-k>     <Plug>(neosnippet_expand_or_jump)
"imap <expr><TAB>
" \ pumvisible() ? "\<C-n>" :
" \ neosnippet#expandable_or_jumpable() ?
" \    "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"
smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
\ "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"

" For conceal markers.
if has('conceal')
  set conceallevel=2 concealcursor=niv
endif

'''

[[plugins]]
repo = 'vim-scripts/ShowMarks'
hook_add = 'let g:showmarks_include="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"'

[[plugins]]
repo = 'mattn/calendar-vim'

[[plugins]]
repo = 'yaasita/edit-slack.vim'
if = 'exists("g:yaasita_slack_token")'

# [[plugins]]
# repo = 'natebosch/vim-lsc'
# hook_add = '''
# " Map a filetype to the command that starts the language server for that filetype in your vimrc.
# " vimrcでそのファイルタイプの言語サーバを起動するコマンドにファイルタイプをマップします。
# " let g:lsc_server_commands = { 'dart' : 'dart_language_server'}
# " To disable autocomplete in favor of manual completion also add
# " let g:lsc_enable_autocomplete = v:false
#
# " Most interactive features are triggered by commands, you can map keys to these commands, or use g:lsc_auto_map to have them automatically mapped for the buffers which have a language server enabled.
# " You can use the default mappings by setting it to v:true, or specify your own mappings in a dict.
# " The 'Complete' key will set a completion function only if g:lsc_enable_autocomplete is false.
# " ほとんどのインタラクティブな機能はコマンドによってトリガされ、キーをこれらのコマンドにマップするか、g：lsc_auto_mapを使用して、言語サーバが有効になっているバッファ用に自動的にマッピングされます。
# " デフォルトマッピングをv：trueに設定するか、またはdictに独自のマッピングを指定して使用することができます。
# " 'Complete'キーは、g：lsc_enable_autocompleteがfalseの場合にのみ完了関数を設定します。
#
# let g:lsc_auto_map = v:true " Use defaults
# " ... or set only the keys you want mapped, defaults are:
# let g:lsc_auto_map = {
#     \ 'GoToDefinition': '<C-]>',
#     \ 'FindReferences': 'gr',
#     \ 'ShowHover': 'K',
#     \ 'Completion': 'completefunc',
#     \}
# '''




